---
layout: single
title:  "[컴퓨터 구조와 운영체제] 데이터"
categories: ComputerStructure&OS
tag: ComputerStructure&OS
toc: true
author_profile: false
sidebar:
  nav: "docs"
---


## 정보 단위

- 컴퓨터는 0과 1로 모든 정보를 표현하고, 0과 1로 표현된 정보만을 이해할 수 있음
- 비트(bit)는 0과 1을 표현할 수 있는 가장 작은 정보 단위
- n비트는 2의 n제곱 가지 정보를 표현할 수 있음
- 바이트를 제외한 kB, MB, GB, 그 이상의 단위들은 모두 이전 단위를 100개 묶어 표현한 단위임 (1024개씩 묶은 것 X)
    
    
    | 1바이트(1byte) | 8비트(8bit) |
    | --- | --- |
    | 1킬로바이트(1kB) | 1000바이트(1000byte) |
    | 1메가바이트(1MB) | 1000킬로바이트(1000kB) |
    | 1기가바이트(1GB) | 1000메가바이트(1000MB) |
    | 1테라바이트(1TB) | 1000기가바이트(1000GB) |
- 워드(word)는 CPU가 한 번에 처리할 수 있는 데이터 크기
- 현대 컴퓨터의 워드 크기는 대부분 32비트 또는 64비트임
- 워드의 절반 크기를 하프 워드(half word), 1배 크기를 풀 워드(full word), 2배 크기를 더블 워드(double word)라고 함

## 이진법

- 이진법은 1을 넘어가는 시점에 자리 올림을 하여 0과 1만으로 모든 수를 표현하는 방법
- 십진법은 9를 넘어가는 시점에 자리 올림을 하여 0~9로 모든 수를 표현하는 방법
- 이진수는 이진법으로 표현한 수이고, 십진수는 십진법으로 표현한 수
- 이진수를 수학적으로 표기할 때 아래첨자를 붙임   ex) 1000(2)
- 이진수를 코드 상에서 표기할 때 이진수 앞에 0b를 붙임   ex) 0b1000
- 이진수의 음수 표현
    - 2의 보수의 값을 구해 이 값을 음수로 간주함
    - 2의 보수의 사전적 의미는 어떤 수를 그보다 큰 2의 n제곱에서 뺀 값임
    - 1의 보수는 모든 이진수의 0과 1을 뒤집은 수이고, 여기에 1을 더한 값이 2의 보수라고 함 ⇒ 이 수가 음수임
    - 이진수만으로는 양수, 음수 구분이 어려우므로 컴퓨터 내부에서 이를 구분하기 위해 플래그를 사용함
    - 2의 보수 표현의 한계는 0이나 2의 n제곱 형태의 이진수에 2의 보수를 취하면 원하는 음수 값을 얻을 수 없다는 것임

## 십육진법

- 십육진법은 15를 넘어가는 시접에 자리 올림하여 수를 표현하는 방법
- 십육진수는 한 글자로 열 여섯종류(0~9, A~F)의 정보를 표현할 수 있어 이진수에 비해 더 적은 자릿수로 더 많은 정보를 표현 가능함
- 십육진수를 수학적으로 표기할 때 아래첨자를 붙임   ex) 15(16)
- 십육진수를 코드 상에서 표기할 때 0x를 붙임    ex) 0x15
- 이진수를 십육진수로, 십육진수를 이진수로 변환하기 쉬워 십육진법을 사용함

## 십육진수를 이진수로 변환하기

- 십육진수를 이루는 숫자 하나를 이진수로 표현하려면 2의 4제곱이 16이므로 4비트가 필요함
- 십육진수를 이진수로 변환하는 방법은 십육진수를 이루고 있는 각 글자를 따로따로 이진수를 변환하고, 그것들을 이어 붙이면 됨

## 이진수를 십육진수로 변환하기

- 이진수를 십육진수로 변환할 때는 이진수 숫자를 네 개씩 끊고, 끊어 준 네 개의 숫자를 하나의 십육진수로 변환한 뒤 그대로 이어 붙이면 됨

## 문자 집합과 인코딩

- 문자 집합은 컴퓨터가 인식하고 표현할 수 있는 문자들의 모음
- 컴퓨터는 문자 집합에 속해 있는 문자만 이해할 수 있음
- 문자 인코딩은 문자를 컴퓨터가 이해할 수 있는 0과 1로 이루어진 문자 코드로 변환한 것
- 문자 디코딩은 0과 1로 이루어진 문자코드를 사람이 이해할 수 있는 문자로 변환하는 것

## 아스키 코드

- 아스키는 초창기 문자 집합 중 하나로, 영어 알파벳과 아라비아 숫자, 일부 특수 문자를 포함함
- 하나의 아스키 문자를 나타내기 위해 8비트(1바이트)를 사용함
- 1비트는 오류 검출을 위해 사용되는 패리티 비트임
- 문자 표현을 위해 사용되는 비트는 7비트로, 총 128개의 문자를 표현할 수 있음
- 아스키 코드는 아스키 문자에 대응된 고유한 수
- 아스키 문자 집합에 0부터 127까지의 수가 할당되어 아스키 코드로 인코딩 됨
- 문자 인코딩에서 글자에 부여된 고유한 값을 코드 포인트라고 함   ex) 아스키 문자 A의 코드 포인트는 65
- 더 다양한 문자 표현을 위해 8비트의 확장 아스키가 등장했지만 표현 가능한 문자의 수가 턱없이 부족했기에 다른 인코딩 방식이 등장함

## EUC-KR

- 한글 인코딩에는 한글 완성형 인코딩과 한글 조합형 인코딩이 존재함
- 완성형 인코딩 방식은 초성, 중성, 종성의 조합으로 이루어진 완성된 하나의 글자에 고유한 코드를 부여하는 인코딩 방식
- 조합형 인코딩 방식은 초성, 중성, 종성에 해당하는 코드를 합하여 하나의 글자 코드를 만드는 인코드 방식
- EUC-KR은 한글을 2바이트 크기로 인코딩할 수 있는 완성형 인코딩 방식임
- EUC-KR로 인코딩된 한글은 한 글자에 2바이트(16비트)가 부여되므로 십육진수로 나타낼 수 있음
- EUC-KR는 모든 한글을 표현할 수 없다는 한계가 있음 → 확장된 버전의 CP949도 한글 전체를 표현하기에 넉넉한 양X

## 유니코드와 UTF-8

- 유니코드는 여러 나라의 문자를 광범위하게 표현할 수 있는 통일된 문자 집합 → 언어별로 인코딩 하지 않아도 됨
- 유니코드는 글자에 부여된 값 자체를 인코딩된 값으로 삼지 않고 이 값을 다양한 방법으로 인코딩 함
- UTF는 유니코드를 인코딩 하는 방법으로, 인코딩 방법에는 UTF-8, UTF-16, UTF-32가 있음
- UTF-8
    - UTF-8은 통상 1바이트부터 4바이트까지의 인코딩 결과를 만듦
        
        
        | 첫 코드 포인트 | 마지막 코드 포인트 | 1바이트 | 2바이트 | 3바이트 | 4바이트 |
        | --- | --- | --- | --- | --- | --- |
        | 0000 | 007F | 0XXXXXXX |  |  |  |
        | 0080 | 07FF | 110XXXXX | 10XXXXXX |  |  |
        | 0800 | FFFF | 1110XXXX | 10XXXXXX | 10XXXXXX |  |
        | 10000 | 10FFFF | 11110XXX | 10XXXXXX | 10XXXXXX | 10XXXXXX |
    - 유니코드 문자에 부여된 값의 범위가 0부터 007F(16)까지는 1바이트로 표현
    - 유니코드 문자에 부여된 값의 범위가 0080(16)부터 07FF(16)까지는 2바이트로 표현
    - 유니코드 문자에 부여된 값의 범위가 0800(16)부터 FFFF(16)까지는 3바이트로 표현
    - 유니코드 문자에 부여된 값의 범위가 10000(16)부터 10FFFF(16)까지는 4바이트로 표현
    - ‘한글’은 몇 바이트로 구성되는가?
        - ‘한’에 부여된 값은 D55C(16), ‘글’에 부여된 값은 AE00(16)
        - 두 글자 모두 0800(16)과 FFFF(16) 사이에 있으므로 ‘한’과 ‘글’을 UTF-8로 인코딩 하면 3바이트로 표현됨
        - D55C(16)을 이진수로 변환하면 1101 0101 0101 1100(2), AE00(16)을 이진수로 변환하면 1010 1110 0000 0000(2)
        - UTF-8로 인코딩한 결과 ‘한’은 11101101 10010101 10011100(2), ‘글’은 11101010 10111000 10000000(2) 임
