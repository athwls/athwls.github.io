---
layout: single
title:  "[컴퓨터 구조와 운영체제]명령어"
categories: ComputerStructure&OS
tag: ComputerStructure&OS
toc: true
author_profile: false
sidebar:
  nav: "docs"
---


## 고급 언어와 저급 언어

- **고급 언어**는 사람이 이해하고 작성하기 쉽게 만들어진 언어   ex) C, C++, Java, Python
- 컴퓨터가 이해하고 실행할 수 있는 언어는 저급 언어 뿐이므로 고급 언어로 작성된 소스 코드가 실행되려면 반드시 저급 언어, 즉 **명령어**로 변환되어야 함
- **저급 언어**는 컴퓨터가 직접 이해하고 실행할 수 있는 언어
    - 저급 언어에는 기계어와 어셈블리어가 있음
    - **기계어**는 0과 1로 이루어진 명령어로 구성된 저급 언어 (이진수 대신 십육진수로 표현하기도 함)
    - **어셈블리어**는 0과 1로 이루어진 기계어를 읽기 편한 형태로 번역한 저급 언어

## 컴파일 언어와 인터프리터 언어

- 고급 언어를 저급 언어로 변환하는 방법에는 컴파일 방식과 인터프리트 방식이 있음
- 컴파일 방식으로 작동하는 프로그래밍 언어는 컴파일 언어
- 인터프리트 방식으로 작동하는 프로그래밍 언어는 인터프리터 언어
- 컴파일 언어
    - **컴파일 언어**는 컴파일러에 의해 소스 코드 전체가 저급 언어로 변환되어 실행되는 고급 언어   ex) C
    - **컴파일**은 컴파일 언어로 작성된 소스 코드의 코드 전체가 저급 언어로 변환되는 과정을 말함
    - **컴파일러**는 컴파일을 수행해주는 도구
    - 컴파일러가 소스 코드를 처음부터 끝까지 저급 언어로 컴파일 할 때 소스 코드 내에서 오류를 하나라도 발견하면 해당 소스 코드는 컴파일에 실패함
    - **목적 코드**는 컴파일러를 통해 저급 언어로 변환된 코드
- 인터프리터 언어
    - **인터프리터 언어**는 인터프리터에 의해 소스 코드가 한 줄씩 실행되는 고급 언어   ex) Python
    - **인터프리터**는 소스 코드를 한 줄씩 저급 언어로 변환하여 실행해주는 도구
- 인터프리터 언어는 컴파일 언어보다 느림
- 하나의 프로그래밍 언어가 반드시 컴파일 방식과 인터프리터 방식 중 하나의 방식으로만 작동하는 것은 아님

## 목적파일과 실행파일

- **목적 파일**은 목적 코드로 이루어진 파일
- **실행 파일**은 실행 코드로 이루어진 파일   ex) 윈도우의 .exe 확장자를 가진 파일
- 목적 파일이 실행 파일이 되기 위해서는 링킹 이라는 작업을 거쳐야 함
- **링킹**은 목적 파일을 연결하여 하나의 실행 파일을 만드는 것임

## 연산 코드와 오퍼랜드

- 명령어는 연산 코드와 오퍼랜드로 구성되어 있음
- **연산 코드**는 명령어가 수행할 연산 → 연산자
- **오퍼랜드**는 연산에 사용할 데이터 또는 연산에 사용할 데이터가 저장된 위치 → 피연산자
- **연산 코드 필드**는 연산 코드가 담기는 영역
- **오퍼랜드 필드**는 오퍼랜드가 담기는 영역
- 오퍼랜드
    - 오퍼랜드 필드에는 숫자와 문자 등을 나타내는 데이터 또는 메모리나 레지스터 주소가 올 수 있음
    - 오퍼랜드 필드에는 데이터를 직접 명시하기 보다 데이터가 저장된 위치인 메모리 주소나 레지스터 이름이 담김 → 오퍼랜드 필드를 **주소 필드**라고도 부름
    - 오퍼랜드는 명령어 안에 하나도 없을 수도 있고, 한 개 또는 여러 개가 있을 수 있음
    - **0-주소 명령어**는 오퍼랜드가 하나도 없는 명령어
    - **1-주소 명령어**는 오퍼랜드가 하나인 명령어
    - **2-주소 명령어**는 오퍼랜드가 두 개인 명령어
    - **3-주소 명령어**는 오퍼랜드가 세 개인 명령어
- 연산코드 유형
    - 데이터 전송
        - MOVE : 데이터를 옮겨라
        - STORE : 메모리에 저장하라
        - LOAD(FETCH) : 메모리에서 CPU로 데이터를 가져와라
        - PUSH : 스택에 데이터를 저장하라
        - POP : 스택의 최상단 데이터를 가져와라
    - 산술/논리 연산
        - ADD / SUBTRACT / MULTIPLY / DIVIDE : 덧셈 / 뺄셈 / 나눗셈을 수행하라
        - INCREMENT / DECREMENT : 오퍼랜드에 1을 더하라 / 오퍼랜드에 1을 빼라
        - AND / OR / NOT : AND / OR / NOT 연산을 수행하라
        - COMPARE : 두 개의 숫자 또는 TRUE / FALSE 값을 비교하라
    - 제어 흐름 변경
        - JUMP : 특정 주소로 실행 순서를 옮겨라
        - CONDITIONAL JUMP : 조건에 부합할 때 특정 주소로 실행 순서를 옮겨라
        - HALT : 프로그램의 실행을 멈춰라
        - CALL : 되돌아올 주소를 저장한 채 특정 주소로 실행 순서를 옮겨라
        - RETURN : CALL을 호출할 때 저장했던 주소로 돌아가라
    - 입출력 제어
        - READ(INPUT) : 특정 입출력 장치로부터 데이터를 읽어라
        - WRITE(OUTPUT) : 특정 입출력 장치로 데이터를 써라
        - START IO : 입출력 장치를 시작하라
        - TEST IO : 입출력 장치의 상태를 확인하라
        
    
    ## 주소 지정 방식
    
    - 오퍼랜드에 연산 코드에 사용될 데이터가 아닌 메모리 주소가 담긴다면 데이터의 크기는 하나의 메모리 주소에 저장할 수 있는 공간만큼 커짐
    - 오퍼랜드 필드에 레지스터 이름을 명시한다면 표현할 수 있는 정보의 가짓수는 해당 레지스터가 저장할 수 있는 공간만큼 커짐
    - **유효 주소**는 연산의 대상이 되는 데이터가 저장된 위치
    - **주소 지정 방식**은 연산에 사용할 데이터 위치를 찾는 방법 → 유효 주소를 찾는 방법
    - 즉시 주소 지정 방식
        - **즉시 주소 지정 방식**은 **연산에 사용할 데이터**를 오퍼랜드 필드에 직접 명시하는 방식
        - 표현할 수 있는 데이터의 크기가 작아짐
        - 연산에 사용할 데이터를 메모리나 레지스터로부터 찾는 과정이 없기 때문에 다른 주소 지정 방식들보다 빠름
    - 직접 주소 지정 방식
        - **직접 주소 지정 방식**은 오퍼랜드 필드에 **유효 주소(메모리 주소)**를 직접적으로 명시하는 방식
        - 표현할 수 있는 오퍼랜드 필드의 길이가 연산 코드의 길이만큼 짧아져 표현할 수 있는 유효주소에 제한이 생길 수 있음 → 즉시 주소 지정 방식보다는 표현할 수 있는 데이터 크기가 커짐
    - 간접 주소 지정 방식
        - **간접 주소 지정 방식**은 **유효 주소의 주소**를 오퍼랜드 필드에 명시함
        - 직접 주소 방식보다 표현할 수 있는 유효 주소의 범위가 더 넓어짐
        - 두 번의 메모리 접근이 필요하기 때문에 다른 주소 지정 방식들보다 느림
    - 레지스터 주소 지정 방식
        - **레지스터 주소 지정 방식**은 직접 주소 지정 방식과 비슷하게 연산에 사용할 데이터를 저장한 **레지스터(유효 주소)**를 오퍼랜드 필드에 직접 명시하는 방법
        - CPU 외부에 있는 메모리에 접근하는 것보다 CPU 내부에 있는 레지스터에 접근하는 것이 더 빠름
        - 레지스터 주소 지정 방식은 직접 주소 지정 방식보다 빠르게 데이터에 접근할 수 있음
        - 표현할 수 있는 레지스터 크기에 제한이 생길 수 있음
    - 레지스터 간접 주소 지정 방식
        - **레지스터 간접 주소 지정 방식**은 연산에 사용할 데이터를 메모리에 저장하고, **그 주소(유효 주소)를 저장한 레지스터**를 오퍼랜드 필드에 명시하는 방법
        - 메모리에 접근하는 횟수가 한 번으로 줄어들기 때문에 간접 주소 지정 방식보다 빠름
        
    
    ## 스택과 큐
    
    - 스택이란 한쪽 끝이 막혀 있는 통과 같은 저장 공간
    - **스택**은 나중에 저장한 데이터를 가장 먼저 빼내는 데이터 관리 방식(후입선출)으로 **LIFO**(리포) 자료구조라고 불림
    - 스택에 새로운 데이터를 저장하는 명령어가 **PUSH**, 스택에 저장된 데이터를 꺼내는 명령어가 **POP**임
    - 큐는 양쪽이 뚫려 있는 통과 같은 저장 공간
    - **큐**는 가장 먼저 저장된 데이터부터 빼내는 데이터 관리방식(선입선출)으로 **FIFO**(피포) 자료 구조라고 불림
    
    ### 참조
    
    위 글은 강민철 님의 혼자 공부하는 컴퓨터구조+운영체제를 읽고 작성한 글입니다. 
    
    [혼자 공부하는 컴퓨터 구조+운영체제 ](https://search.shopping.naver.com/book/catalog/33824626625)
