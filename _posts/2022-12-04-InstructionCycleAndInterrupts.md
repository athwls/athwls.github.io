---
layout: single
title:  "[컴퓨터 구조와 운영체제] CPU의 작동원리"
categories: ComputerStructure&OS
tag: ComputerStructure&OS
toc: true
author_profile: false
sidebar:
  nav: "docs"
---


## ALU

- **ALU**는 레지스터와 제어장치로부터 받아들인 **피연산자**와 **제어 신호**로 산술연산, 논리 연산 등 다양한 연산을 수행함
- ALU의 결괏값을 메모리가 아닌 레지스터에 우선 저장함
- 플래그
    - ALU는 계산 결과와 더불어 **플래그**를 내보냄
    - **플래그**는 CPU가 프로그램을 실행하는 도중 반드시 기억해야할 연산 결과에 대한 추가적인 상태 정보
        
        
        | 플래그 종류 | 의미 | 사용 예시 |
        | --- | --- | --- |
        | 부호 플래그 | 연산한 결과의 부호를 나타냄 | 부호 플래그가 1일 경우 계산 결과는 음수, 0일 경우 계산 결과는 양수를 의미함 |
        | 제로 플래그 | 연산한 결과가 0인지 여부를 나타냄 | 제로 플래그가 1일 경우 연산 결과는 0, 0일 경우 연산 결과는 0이 아님을 의미함 |
        | 캐리 플래그 | 연산 결과 올림수나 빌림수가 발생했는지 나타냄 | 캐리 플래그가 1일 경우 올림수나 빌림수가 발생했음을 의미하고, 0일 경우 발생하지 않았음을 의미함 |
        | 오버플로우 플래그 | 오버플로우가 발생했는지 나타냄 | 오버플로우 플래그가 1일 경우 오버플로우가 발생했음을 의미하고, 0일 경우 발생하지 않았음을 의미함 |
        | 인터럽트 플래그 | 인터럽트가 가능한지 나타냄 | 인터럽트 플래그가 1일 경우 인터럽트가 가능함을 의미하고, 0일 경우 인터럽트가 불가능함을 의미함 |
        | 슈퍼바이저 플래그 | 커널 모드로 실행 중인지, 사용자 모드로 실행 중인지 나타냄 | 슈퍼바이저 플래그가 1일 경우 커널 모드로 실행 중임을 의미하고, 0일 경우 사용자 모드로 실행 중임을 의미함 |
    - 플래그들은 **플래그 레지스터**에 저장됨

## 제어장치

- **제어 장치**는 제어 신호를 내보내고, 명령어를 해석하는 부품
- **제어 신호**는 컴퓨터 부품들을 관리하고 작동시키기 위한 일종의 전기 신호
- 제어 장치가 받아들이는 정보
    - 제어장치는 **클럭 신호**를 받아들임
        - **클럭**이란 컴퓨터의 모든 부품을 일사불란하게 움직일 수 있게 하는 시간 단위
        - 클럭의 주기에 맞춰 한 레지스터에서 다른 레지스터로 데이터가 이동되거나, ALU에서 연산이 수행되거나, CPU가 메모리에 저장된 명령어를 읽어 들이는 것임
        - 컴퓨터 부품들은 클럭이라는 박자에 맞춰 작동할 뿐 한 박자마다 작동하는 것은 아님
    - 제어장치는 **현재 수행할 명령어(=해석해야 할 명령어)**를 받아들임
        - CPU가 해석해야 할 명령어는 **명령어 레지스터**에 저장됨
        - 제어장치는 명령어 레지스터로부터 해석할 명령어를 받아들이고 해석한 뒤, 제어 신호를 발생시켜 컴퓨터 부품들에 수행해야 할 내용을 알려줌
    - 제어장치는 플래그 레지스터 속 **플래그 값**을 받아들임
        - 플래그는 ALU 연산에 대한 추가적인 상태 정보
        - 제어장치는 플래그 값을 받아들이고 이를 참고하여 제어 신호를 발생시킴
    - 제어장치는 시스템 버스 중 제어 버스로 전달된 **제어 신호**를 받아들임
        - 제어 신호는 CPU 뿐만 아니라 입출력장치를 비롯한 CPU 외부 장치도 발생시킬 수 있음
        - 제어장치는 제어 버스를 통해 외부로부터 전달된 제어 신호를 받아들임
        - 제어장치가 **CPU 외부**에 전달하는 제어 신호는 **메모리**에 전달하는 제어 신호와 **입출력장치**에 전달하는 제어신호가 있음
        - 제어장치가 메모리에 저장된 값을 읽거나 메모리에 새로운 값을 쓰고 싶을 때 메모리로 제어 신호를 내보냄
        - 제어장치가 입출력장치의 값을 읽거나 입출력장치에 새로운 값을 쓰고 싶을 때 입출력장치로 신호를 내보냄
        - 제어장치가 **CPU 내부**에 전달하는 제어 신호에는 **ALU**에 전달하는 제어 신호와 **레지스터**에 전달하는 제어 신호가 있음
        - 제어장치가 수행할 연산을 지시하기 위해 ALU에 제어 신호를 내보냄
        - 제어장치가 레지스터 간에 데이터를 이동시키거나 레지스터에 저장된 명령어를 해석하기 위해 제어 신호를 내보냄
        

## 레지스터

- 상용화된 CPU 속 레지스터들은 CPU마다 이름, 크기, 종류가 매우 다양함
- 프로그램 카운터
    - **프로그램 카운터**는 메모리에서 읽어 들일 명령어의 주소를 저장함
    - **명령어 포인터**라고도 부름
- 명령어 레지스터
    - **명령어 레지스터**는 방금 메모리에서 읽어 들인 명령어를 저장하는 레지스터
    - 제어장치는 명령어 레지스터 속 명령어를 받아들이고 해석한 뒤 제어 신호를 내보냄
- 메모리 주소 레지스터
    - **메모리 주소 레지스터**는 메모리의 주소를 저장하는 레지스터
    - CPU가 읽어 들이고자 하는 주소 값을 주소 버스로 보낼 때 메모리 주소 레지스터를 거치게 됨
- 메모리 버퍼 레지스터(=메모리 데이터 레지스터)
    - **메모리 버퍼 레지스터**는 메모리와 주고받을 값(데이터와 명령어)을 저장하는 레지스터
    - CPU가 데이터 버스로 주고받을 값이 메모리 버퍼 레지스터를 거치게 됨
- 메모리에 저장된 프로그램을 실행하는 과정
    1. 프로그램을 처음부터 실행하기 위해 프로그램 카운터에 프로그램의 첫번째 메모리 주소가 저장됨 (이 주소를 1000번지라고 하자)
    2. 1000번지를 읽어 들이기 위해서는 주소 버스로 1000번지를 내보내야 함 → 메모리 주소 레지스터에 1000번지가 저장됨
    3. 메모리 읽기 제어 신호와 메모리 주소 레지스터 값이 각각 제어 버스와 주소 버스를 통해 메모리로 보내짐
    4. 메모리 1000번지에 저장된 값은 데이터 버스를 통해 메모리 버퍼 레지스터로 전달되고, 프로그램 카운터는 증가되어 다음 명령어를 읽어 들일 준비를 함 
    5. 메모리 버퍼 레지스터에 저장된 값은 명령어 레지스터로 이동함
    6. 제어장치는 명령어 레지스터의 명령어를 해석하고 제어 신호를 발생시킴
    - CPU가 메모리 속 프로그램을 순차적으로 읽어 들이고 실행해 나갈 수 있는 이유는 CPU 속 프로그램 카운터가 꾸준히 증가하기 때문임
    - 명령어 중 JUMP, CONDITIONAL JUMP, CALL, RET와 같이 특정 메모리 주소로 실행 흐름을 이동하는 명령어가 실행되었을 때 프로그램은 차례대로 실행되지 않음 → 프로그램 카운터에 변경된 주소가 저장됨
    - 인터럽트가 발생해도 프로그램의 순차적인 실행 흐름이 끊어짐
- 플래그 레지스터
    - **플래그 레지스터**는 연산 결과 또는 CPU 상태에 대한 부가적인 정보를 저장하는 레지스터
- 범용 레지스터
    - **범용 레지스터**는 다양하고 일반적인 상황에서 자유롭게 사용할 수 있는 레지스터
    - 데이터와 주소를 모두 저장할 수 있음
    - CPU 안에 여러 개의 범용 레지스터들이 있고, 현재 대다수 CPU는 모두 범용 레지스터를 가지고 있음
- 스택 포인터
- 베이스 레지스터

## 특정 레지스터를 이용한 주소 지정방식

### 스택 주소 지정 방식

- 프로그램 카운터, 스택 포인터, 베이스 레지스터는 주소 지정에 사용될 수 있는 특별한 레지스터임
- **스택 주소 지정 방식**은 스택과 스택 포인터를 이용한 주소 지정 방식임
- **스택 포인터**는 스택의 꼭대기를 가리키는 레지스터 (=스택에 마지막으로 저장한 값의 위치를 저장하는 레지스터)
- 스택은 메모리 안에 스택처럼 사용할 영역이 정해져 있는데 이 영역을 **스택 영역**이라고 함

### 변위 주소 지정 방식

- **변위 주소 지정 방식**은 오퍼랜드 필드의 값(변위)과 특정 레지스터의 값을 더하여 유효 주소를 얻어내는 주소 지정 방식
- 변위 주소 지정 방식을 사용하는 명령어는 연산 코드 필드, 어떤 레지스터의 값과 더할지 나타내는 레지스터 필드, 주소를 담고 있는 오퍼랜드 필드가 있음
- 변위 주소 지정 방식은 오퍼랜드 필드의 주소와 어떤 레지스터를 더하는지에 따라 상대 주소 지정 방식, 베이스 레지스터 주소 지정 방식 등으로 나뉨
- 상대 주소 지정 방식
    - **상대 주소 지정 방식**은 오퍼랜드와 **프로그램 카운터**의 값을 더하여 유효 주소를 얻는 방식
    - 상대 주소 지정 방식은 프로그래밍 언어의 IF문과 유사하게 모든 코드를 실행하는 것이 아닌, 분기하여 특정 주소의 코드를 실행할 때 사용됨
- 베이스 레지스터 주소 지정 방식
    - **베이스 레지스터 주소 지정 방식**은 오퍼랜드와 **베이스 레지스터**의 값을 더하여 유효 주소를 얻는 방식
    - 베이스 레지스터 주소 지정 방식은 베이스 레지스터 속 기준 주소로부터 얼마나 떨어져 있는 주소에 접근할 것인지를 연산하여 유효 주소를 얻어내는 방식
    

## 명령어 사이클

- 실행하는 프로그램은 수많은 명령어로 이루어져 있고, CPU는 이 명령어들을 하나씩 실행함
- 프로그램 속 각각의 명령어들은 일정한 주기가 반복되며 실행되는데, 이 주기를 **명령어 사이클** 이라고 함
- **명령어 사이클**은 하나의 명령어가 처리되는 주기
- **인출 사이클**은 명령어 사이클의 첫 번째 과정으로 메모리에 있는 명령어를 CPU로 가지고 오는 단계
- **실행 사이클**은 명령어 사이클의 두 번째 과정으로 CPU로 가져온 명령어를 실행하는 단계
- 실행 사이클은 제어장치가 명령어 레지스터에 담긴 값을 해석하고, 제어 신호를 발생시키는 단계
- 간접 주소 지정 방식은 오퍼랜드 필드에 유효 주소의 주소를 명시하므로 바로 실행 사이클에 돌입할 수 없음
- 명령어를 실행하기 위해서 메모리 접근을 한 번 더 해야 하는 단계를 **간접 사이클** 이라고 함
- 어떤 명령어는 인출과 실행 사이클만으로 실행되고, 어떤 명령어는 인출, 간접, 실행 사이클을 거쳐 실행됨

## 인터럽트

- **인터럽트**는 CPU의 정상적인 작업을 방해하는 신호
- 인터럽트의 종류
    - 동기 인터럽트(=예외)
        - **동기 인터럽트**는 CPU에 의해 발생하는 인터럽트
        - 동기 인터럽트는 CPU가 실행하는 프로그래밍상의 오류와 같은 예외적인 상황에 마주쳤을 때 발생하는 인터럽트이므로 **예외**라고 부름
    - 비동기 인터럽트(=하드웨어 인터럽트)
        - **비동기 인터럽트**는 주로 입출력장치에 의해 발생하는 인터럽트
        - 일반적으로 비동기 인터럽트를 인터럽트라 칭하기도 하지만 혼동을 방지하기 위해 **하드웨어 인터럽트**라고 함
- 예외
    - 예외가 발생하면 CPU는 하던 일을 중단하고 해당 예외를 처리함
    - 예외를 처리하고 나면 CPU는 다시 본래 하던 작업으로 되돌아와 실행을 재개함
    - CPU가 본래 하던 작업으로 되돌아왔을 때 예외가 발생한 명령어부터 실행하느냐, 예외가 발생한 명령어의 다음 명령어부터 실행하느냐에 따라 폴트와 트랩으로 나뉨
    - 폴트
        - **폴트**는 예외를 처리한 직후 예외가 발생한 명령어부터 실행을 재개하는 예외
    - 트랩
        - **트랩**은 예외를 처리한 직후 예외가 발생한 명령어의 다음 명령어부터 실행을 재개하는 예외
        - 디버깅할 때 사용함
        - **디버깅**이란 프로그램 개발 중에 발생한 문제를 진단하고 해결하기 위한 작업
    - 중단
        - **중단**은 CPU가 실행 중인 프로그램을 강제로 중단시킬 수밖에 없는 심각한 오류를 발견했을 때 발생하는 예외
    - 소프트웨어 인터럽트
        - **소프트웨어 인터럽트**는 시스템 호출이 발생했을 때 나타남
- 하드웨어 인터럽트
    - **하드웨어 인터럽트**는 알림과 같은 인터럽트
    - 하드웨어 인터럽트를 이용하면 CPU는 주기적으로 프린트 완료 여부를 확인할 필요 없이 프린터로부터 프린트 완료 인터럽트를 받을 때까지 다른 작업을 처리할 수 있음
    - CPU는 입출력 작업 도중에 효율적으로 명령어를  처리하기 위해 알림과 같은 하드웨어 인터럽트를 사용함
- 하드웨어 인터럽트 처리 순서
    1. 입출력장치는 CPU에 **인터럽트 요청 신호**를 보냄
    2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부를 확인함
    3. CPU는 인터럽트 요청을 확인하고 **인터럽트 플래그**를 통해 현재 인터럽트를 받아들일 수 있는지 여부를 확인함 
    4. 인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업을 백업함
    5. CPU는 인터럽트 벡터를 참조하여 인터럽트 서비스 루틴을 실행함
    6. 인터럽트 서비스 루틴 실행이 끝나면 4에서 백업해 둔 작업을 복구하여 실행을 재개함
    
    - **인터럽트 요청 신호**는 CPU의 정상적인 실행 흐름을 끊어도 되는지 CPU에게 물어보는 것임
    - CPU가 인터럽트 요청을 수용하기 위해서는 플래그 레지스터인 **인터럽트 플래그**가 활성화 되어 있어야 함
    - 하드웨어 인터럽트에는 인터럽트 플래그로 **막을 수 있는 인터럽트**와 **막을 수 없는 인터럽트**가 있음
    - 정전이나 하드웨어 고장으로 인한 인터럽트는 인터럽트 플래그가 ‘불가능’으로 설정되어 있을지라도 무시할 수 없는 인터럽트로, 가장 먼저 처리해야 함
    - CPU가 인터럽트 요청을 받아들이기로 했다면 CPU는 인터럽트 서비스 루틴이라는 프로그램을 실행함
    - **인터럽트 서비스 루틴**은 인터럽트를 처리하기 위한 동작들로 이루어진 프로그램으로 **인터럽트 핸들러** 라고도 부름
    - 인터럽트를 처리하는 방법은 입출력장치마다 다르므로 각기 다른 인터럽트 서비스 루틴을 가지고 있음 → 메모리에는 여러 개의 인터럽트 서비스 루틴이 저장되어 있음
    - CPU는 수많은 인터럽트 서비스 루틴을 구분하기 위해 인터럽트 벡터를 이용함
    - **인터럽트 벡터**는 인터럽트 서비스 루틴을 식별하기 위한 정보
    - 인터럽트 벡터를 알면 인터럽트 서비스 루틴의 시작 주소를 알 수 있기 때문에 CPU는 인터럽트 벡터를 통해 특정 인터럽트 서비스 루틴을 처음부터 실행할 수 있음
    - CPU는 하드웨어 인터럽트 요청을 보낸 대상으로부터 데이터 버스를 통해 인터럽트 벡터를 전달받음
    - ‘CPU가 인터럽트를 처리한다’ 라는 말은 ‘인터럽트 서비스 루틴을 실행하고, 본래 수행하던 작업으로 다시 되돌아온다’ 라는 말과 동일함
    - 인터럽트 서비스 루틴은 여느 프로그램과 마찬가지로 명령어와 데이터로 이루어져 있기 때문에 프로그램 카운터를 비롯한 레지스터들을 사용하며 실행됨
    - CPU는 인터럽트 서비스 루틴을 실행하기 전에 프로그램 카운터 값 등 현재  프로그램을 재개하기 위해 필요한 모든 내용을 스택에 백업함
    - 인터럽트 서비스 루틴의 시작 주소가 위치한 곳으로 프로그램 카운터 값을 갱신하고 인터럽트 서비스 루틴을 실행함
    - 인터럽트 서비스 루틴을 모두 실행하면, 스택에 저장해 둔 값을 다시 불러온 뒤 이전까지 수행하던 작업을 재개함
    - **명령어 사이클**은 인출, 실행, 간접, 인터럽트 사이클로 구성되어 있음

### 참조

위 글은 강민철 님의 혼자 공부하는 컴퓨터구조+운영체제를 읽고 작성한 글입니다. 

[혼자 공부하는 컴퓨터 구조+운영체제](https://search.shopping.naver.com/book/catalog/33824626625)
